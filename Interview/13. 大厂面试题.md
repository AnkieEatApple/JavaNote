## 大厂面试题.md
1. 整理网上遇到的一些大厂的面试题，排名不分先后，直接带问题答案
2. 主要分为三类，分别为Java基础知识类、数据库类、框架知识点类、项目遇到的问题类，暂时先这么区分，后面若是有新的分类条件再进行改动


##### 1. 目录
- [Java基础知识类](#java)
- [数据库类](#database)
- [框架知识点类](#framework)
- [项目遇到的问题类](#project)


### 一、<span id="java">Java基础知识类</span>
1. 主要分为基础知识、容器、线程、设计模式、异常

##### 1. 目录
- [基础知识]()
- [容器]()
- [线程]()
- [设计模式]()
- [异常]()

#### 1.1 基础知识
1. JDK和JRE的区别？
	* JDK是Java的核心，包括Java运行环境JRE，一堆Java工具和Java基础的类库，开发人员将源码编译成字节码(class)文件，JRE是运行环境，不含开发环境，即没有编译器和调试器，将class文件加载到内存准备运行。

2. final关键字，抽象类可以使用final修饰么？
	* final用来修饰数据，包括成员变量、局部变量，该变量只能被赋值一次且他的值无法被改变，对于成员变量来讲，必须在生命时或者构造方法中对它复制
	* 修饰方法，表示该方法无法被重写
	* 修饰类，表示类无法被继承，抽象类不能用final修饰


#### 1.2 容器相关
1. 什么是Java容器？
	* ArrayList：底层数组实现，封装了常见的增删改查操作，并支持动态扩容，动态因子是0.75，默认创建的大小是16，初始化最好有list的大小
	* ListList：基于链表实现的列表，适合增删情况的操作
	* **TreeSet**：基于二叉排序树(红黑树)实现的，最典型就是它用到了两种排序方式，即基于元素对象自身的实现的Comparator接口的自然排序，以及基于更为灵活不与单个元素绑定Comparator几口的客户话排序，自己在构造的时候传入一个比较器即可。
	* HashMap：用来储存键值对的映射关系，底层JDK8以前是数组+链表实现的，JDK8+是数组+红黑树实现的，结合put操作，HashSet其实就是基于HashMap实现的，只不过将值固定为一个固定的值。
	* LinkedHashMap：支持按照插入顺序排序
	* PriorityQueue：优先级队列，一个基于优先级堆的无界优先级队列。



#### 1.3 线程相关
1. Java如何保证线程安全？
	* 线程安全主要在三个方面体现，1）原子性、2）可见性、3）有序性
	* 原子性：提供互斥访问，同一个时刻只能有一个线程堆数据进行操作
	* 可见性：一个线程堆住内存的修改可以及时地被其他线程看到
	* 有序性：一个线程观察其他线程中的指令顺序，由于指令重排序，该观察结果一般杂乱无绪(**happens-before原则**)

2. 如何保证原子性？
	* **锁和同步**，常用保证Java操作原子性的佛能根据时锁和同步方法(或者同步代码块)。
	* 使用锁，可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。
	* 与锁类似的事同步方法或者同步代码块。
		* 使用非静态同步方法时，锁住的是当前实例；
		* 使用静态同步方法时，锁住的是该类的class对象；
		* 使用静态代码块时，锁住的是synchronized关键字后面括号内的对象。
		* 无论使用锁还是synchronized，本质都是一样的，通过锁来实现资源的排它性，属于悲观锁，从而使目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性，是一种以牺牲性能为代价的方法。

3. 如何保证可见性？
	* Java提供了volatile关键字来保证可见性，由于JMM是基于共享内存实现线程通信的，所以存在缓存一执行的问题。当使用volatile修饰某个变量时，他会保证对该变量的修改立即被更新到内存中(这里涉及了JMM的两块内存区域的问题，线程的私有内存和主内存的问题)，并且将其他缓存中对该变量的缓存置成无效，因此其他线程需要读取该值时，必须从住内存中读取，从而得到最新的值。

4. 如何保证顺序性？
	* 编译器和处理器对指令进行重排序时，会保证重新排序后的执行结果和代码顺序执行的结果一致，所以重新排序的过程并不会影响但线程程序执行，却可能影响多线程程序并发执行的正确性。
	* Java中可以通过volatile在一定的顺序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。synchronized和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。
	* 除了从应用层面保证目标代码段执行的顺序性外，JVM还通过被称为happens-before原则隐士地保证顺序性。两个操作的执行顺序只要可以通过happens-before推到出来，则JVM会保证其顺序性，反之JVM对其顺序性不做任和保证，可对其进行任意必要的重新排序以获取高效率。

5. 有没有其他的方法保证线程安全？
	* 有，尽量避免引起非线程安全的条件--共享变量。如果能从设计上避免共享变量的使用，即可避免非线程安全的发生，也就无需通过锁或者synchronized以及volatile解决原子性、可见性、顺序性的问题
	* 还有不可变对象，可以使用final修饰的对象保证线程安全，由于final修饰的引用变量(除String外)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，即不能对外提供可以修改final对象的接口。

#### 1.4 设计模式



#### 1.5 异常



### 二、<span id="database">数据库类</span>
1. 主要分为MySQL和Redis两种分类







### 三、<span id="framework">框架知识点类</span>





### 四、<span id="project">项目遇到的问题类</span>

