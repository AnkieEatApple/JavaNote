## 算法答案.md
* 参考的牛客网和静数秋天博主的帖子，整理的只有题目，用作刷题题目用
* [牛客算法基础提升班](https://www.nowcoder.com/courses/semester/2018algorithm-higher)
* [[剑指offer] JAVA版题解（完整版）](https://blog.csdn.net/weiwei121451070/article/details/81742418)
* 然后发现自己很无聊


#### 1. <span id="1">目录</span>

01. [二维数组中的查找-数组](#二维数组中的查找)
02. [替换空格-字符串](#替换空格)
03. [从尾到头打印链表-链表](#从尾到头打印链表)
04. [重建二叉树-树](#重建二叉树)
05. [用两个栈实现队列-栈、队列](#用两个栈实现队列)
06. [旋转数组的最小数字-数组](#旋转数组的最小数字)
07. [斐波那契数列-数组](#斐波那契数列)
08. [二进制中1的个数-数组](#二进制中1的个数)
09. [数值的整数次方-数值](#数值的整数次方)
10. [调整数组顺序使奇数位于偶数前面-数组](#调整数组顺序使奇数位于偶数前面)
11. [链表中倒数第k个结点-链表](#链表中倒数第k个结点)
12. [反转链表-链表](#反转链表)
13. [合并两个排序的链表-链表](#合并两个排序的链表)
14. [树的子结构-树](#树的子结构)
15. [二叉树的镜像-树](#二叉树的镜像)
16. [顺时针打印矩阵-数组](#顺时针打印矩阵)
17. [包含min函数的栈-栈](#包含min函数的栈)
18. [栈的压入、弹出序列-栈](#栈的压入、弹出序列)
19. [从上往下打印二叉树-树](#从上往下打印二叉树)
20. [二叉搜索树的后序遍历序列-树](#二叉搜索树的后序遍历序列)
21. [二叉树中和为某一值的路径-树](#二叉树中和为某一值的路径)
22. [复杂链表的复制-链表](#复杂链表的复制)
23. [二叉搜索树与双向链表-树、链表](#二叉搜索树与双向链表)
24. [字符串的排列-字符串](#字符串的排列)
25. [数组中出现次数超过一半的数字-数组](#数组中出现次数超过一半的数字)
26. [最小的K个数-数组](#最小的K个数)
27. [连续子数组的最大和-数组](#连续子数组的最大和)
28. [整数中1出现的次数(从1到n整数中1出现的次数)-数组](#从1到n整数中1出现的次数)
29. [把数组排成最小的数-数组](#把数组排成最小的数)
30. [丑数-数值](#丑数)
31. [第一个只出现一次的字符-字符串](#第一个只出现一次的字符)
32. [数组中的逆序对-数组](#数组中的逆序对)
33. [两个链表的第一个公共结点-链表](#两个链表的第一个公共结点)
34. [数字在排序数组中出现的次数-数组](#数字在排序数组中出现的次数)
35. [二叉树的深度-树](#二叉树的深度)
36. [数组中只出现一次的数字-数组](#数组中只出现一次的数字)
37. [和为S的两个数字-数值](#和为S的两个数字)
38. [和为S的连续正数序列-数值](#和为S的连续正数序列)
39. [翻转单词顺序列-字符串](#翻转单词顺序列)
40. [左旋转字符串-字符串](#左旋转字符串)
41. [扑克牌顺子-数组](#扑克牌顺子)
42. [孩子们的游戏(圆圈中最后剩下的数)-数组](#圆圈中最后剩下的数字)
43. [求1+2+3+…+n-数值](#求1+2+3+…+n)
44. [不用加减乘除做加法-数值](#不用加减乘除做加法)
45. [把字符串转换成整数-字符串](#把字符串转换成整数)
46. [数组中重复的数字-数组](#数组中重复的数字)
47. [构建乘积数组-数组](#构建乘积数组)
48. [正则表达式匹配-字符串](#正则表达式匹配)
49. [表示数值的字符串-字符串](#表示数值的字符串)
50. [字符流中第一个不重复的字符-字符串](#字符流中第一个不重复的字符)
51. [链表中环的入口结点-链表](#链表中环的入口结点)
52. [删除链表中重复的结点-链表](#删除链表中重复的结点)
53. [二叉树的下一个结点-树](#二叉树的下一个结点)
54. [对称的二叉树-树](#对称的二叉树)
55. [按之字形顺序打印二叉树-树](#按之字形顺序打印二叉树)
56. [把二叉树打印成多行-树](#把二叉树打印成多行)
57. [序列化二叉树-树](#序列化二叉树)
58. [二叉搜索树的第k个结点-树](#二叉搜索树的第k个结点)
59. [数据流中的中位数-数值](#数据流中的中位数)
60. [滑动窗口的最大值-数组](#滑动窗口的最大值)
61. [矩阵中的路径-数组](#矩阵中的路径)
62. [机器人的运动范围-数组](#机器人的运动范围)


### 一、题目内容

<HR>

#### 1. <span id="二维数组中的查找">二维数组中的查找-数组</span>

1. **题目描述**：在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_01 {
    public boolean Find(int target, int[][] array) {
        // 1
        if (array.length == 0 || array[0].length == 0) {
            return false;
        }
        // 2
        int m = array[0].length - 1;
        int n = 0;
        int temp = array[n][m]; 
        while (target != temp) {
            if (m > 0 && n < array.length - 1) {
                if (target > temp) {
                    n = n + 1;
                } else if (target < temp) {
                    m = m - 1;
                }
                temp = array[n][m];
            } else {
                return false;
            }
        } 
        return true;
    }
}
```
</code></pre>
</details>



- [backup](#1)

<HR>

#### 2. <span id="替换空格">替换空格-字符串</span>

1. **题目描述**：
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
2. **解题思路**：
很简单，从后往前遍历就对了。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_02 {
    public String replaceSpace(StringBuffer str) {
        StringBuffer res = new StringBuffer();
        int len = str.length() - 1;
        for (int i = len; i >= 0; i--) {
            if (str.charAt(i) == ' ') {
                res.append("02%");
            } else {
                res.append(str.charAt(i));
            }
        }
        return res.reverse().toString();
    }
}
```
</code></pre>
</details>


- [backup](#1)


<HR>

#### 3. <span id="从尾到头打印链表">从尾到头打印链表-链表</span>

1. **题目描述**：
输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。

2. **解题思路**：
一种方法是利用栈来实现；
另外一种方法是利用三个指针把链表反转，关键是 r 指针保存断开的节点。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_03 {
	 // 注意这里不能把list初始化放在递归函数中
    ArrayList<Integer> list = new ArrayList<>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if (listNode != null) {
            printListFromTailToHead(listNode.next);
            list.add(listNode.val);
        }
        return list;
    }
} 
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 4. <span id="重建二叉树">重建二叉树-树</span>

1. **题目描述**：
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。

2. **解题思路**：
我们知道，前序遍历的第一个节点就是树的根节点，所以我们先根据前序遍历序列的第一个数字创建根结点，接下来在中序遍历序列中找到根结点的位置，根节点的左边就是左子树，右边就是右子树，这样就能确定左、右子树结点的数量。在前序遍历和中序遍历的序列中划分了左、右子树结点的值之后，就可以递归地去分别构建它的左右子树。


<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.Arrays;
public class Solution_04 {
    public TreeNode reConstructBinaryTree(int[] pre, int[] in) {
        if (pre.length == 0 || in.length == 0) {
            return null;
        }
        TreeNode root = new TreeNode(pre[0]);
        for (int i = 0; i < in.length; i++) {
            if (in[i] == pre[0]) {
                // 左子树。注意copyOfRange 函数，左闭右开
                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));
                // 右子树，注意copyOfRange 函数，左闭右开
                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));
                break;
            }
        }
        return root;
    }
    // 前序遍历 ： 根左右
    // 中序遍历 ： 左根右
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 5. <span id="用两个栈实现队列">用两个栈实现队列-栈、队列</span>

1. **题目描述**：
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

2. **解题思路**：
两个栈 stack1 和 stack2:<br/>
push 动作都在 stack1 中进行，
pop 动作在 stack2 中进行。当 stack2 不为空时，直接 pop，当 stack2 为空时，先把 stack1 中的元素 pop 出来，push 到 stack2 中，再从 stack2 中 pop 元素。

<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.Stack;
public class Solution_05 {
    Stack<Integer> stack1 = new Stack<>();
    Stack<Integer> stack2 = new Stack<>();
    public void push(int node) {
        stack1.push(node);
    }
    public int pop() {
        // 这里题目没有要求
        // if (stack1.isEmpty() && stack2.isEmpty()) {
        //     throw new RuntimeException("Queue is empty!");
        // }
        int node;
        if (stack2.isEmpty()) {
            while (!stack1.isEmpty()) {
                node = stack1.pop();
                stack2.push(node);
            }
        }
        return stack2.pop();
    }
}
```
</code></pre>
</details>



- [backup](#1)

<HR>

#### 6. <span id="旋转数组的最小数字">旋转数组的最小数字-数组</span>

1. **题目描述**：
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

2. **解题思路**:
采用二分查找法。
需要考虑三种情况：<br/>
	1. `array[mid] > array[high]:` <br/>
	出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。
	2. `low = mid + 1`<br/>
	`array[mid] == array[high]`<br/>
	出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边
	还是右边,这时只好一个一个试<br/>
	3. `high = high - 1`<br/>
	`array[mid] < array[high]`<br/>
	出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左边。因为右边必然都是递增的。<br/>
	4. `high = mid`<br/>
	注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字。比如 array = [4,6]，<br/>
	array[low] = 4<br/>
	array[mid] = 4 <br/>
	array[high] = 6<br/>
	如果high = mid – 1，就会产生错误， 因此high = mid
	
<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_06 {
    public int minNumberInRotateArray(int[] array) {
        int len = array.length;
        if (len == 0) {
            return 0;
        }
        // 最简单的就是这种，大大方方，简简单单
        // Arrays.sort(array);
        // return array[0];
        int low = 0;
        int height = len - 1;
        while (low < height) {
            int mid = low + (height - low) / 2;
            if (array[mid] > array[height]) {           // [3,4,5,6,0,1,2]
                low = mid + 1;
            } else if (array[mid] == array[height]) {   // [1,0,1,1,1] 或者[1,1,1,0,1]
                height = height - 1;
            } else {                                    // [2,2,3,4,5,6,6]
                height = mid;
            }
        }
        return array[low];
    }
}
```
</code></pre>
</details>



- [backup](#1)

<HR>

#### 7. <span id="斐波那契数列">斐波那契数列-数组</span>

1. **题目描述**:
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
n<=39

2. **解题思路**:
公式:<br/>
f(n) = n, n <= 1
f(n) = f(n-1) + f(n-2), n > 1<br/>
可以直接使用递归的方法：<br/>
if(n<=1) return n;
else return Fibonacci(n-1)+Fibonacci(n-2);<br/>
递归的方法可能会遇到Stack Overflow，
所以我们可以考虑用动态规划的方法来实现。
采用自底向上方法来保存了先前计算的值，为后面的调用服务。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_07 {
    public int Fibonacci(int n) {
        if (n <= 1) {
            return n;
        } else {
            return Fibonacci(n - 1) + Fibonacci(n - 2);
        }
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 8. <span id="二进制中1的个数">二进制中1的个数-数组</span>

1. **题目描述**:
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

2. **解题思路**:
如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。<br/>
**举个例子**：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_08 {
    public int NumberOf1(int n) {
        int count = 0;
        while (n != 0) {
            count += 1;
            // n-1相当于n的二进制1位变为0，为1，这样每次减少二进制中的一个 1
            // eg: 7(111) & 6(110) = (110)
            n &= (n - 1);   
        }
        return count;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 9. <span id="数值的整数次方">数值的整数次方-数值</span>

1. **题目描述**:
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

2. **解题思路**:<br/>
指数为负时，可以先对指数求绝对值，算出次方的结果后再取倒数<br/>
当底数为0，指数为负时，会出现对0求倒数情况，要特殊处理<br/>
0的0次方在数学上没有意义，因此无论输出0还是1都是可以接受的<br/>
在计算次方的时候，除了简单的遍历，我们可以使用递归的思想，如下公式，来减少计算量：

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_09 {
    public double PowerUnisgnedExponent(double base, int exponent) {
        if (base == 0.0){
            return 0.0;
        }
        // 前置结果设为1.0，即当exponent=0 的时候，就是这个结果
        double result = 1.0d;
        // 获取指数的绝对值
        int e = exponent > 0 ? exponent : -exponent;
        // 根据指数大小，循环累乘
        for(int i = 1 ; i <= e; i ++){
            result *= base;
        }
        // 根据指数正负，返回结果
        return exponent > 0 ? result : 1 / result;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 10. <span id="调整数组顺序使奇数位于偶数前面">调整数组顺序使奇数位于偶数前面-数组</span>

1. **题目描述**: 
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

2. **参考代码**: 
最简单的方法就是把奇数和偶数按顺序挑出来，分别放到vector里，最后再把偶数的vector接到奇数vector的末尾。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_10 {
    public void reOrderArray(int[] array) {
        for (int i = 0; i < array.length; i++) {
            for (int j = 0;j < array.length - 1; j++) {
                if (array[j] % 2 == 0 && array[j + 1] %2 != 0) {
                    int temp = array[j + 1];
                    array[j + 1] = array[j];
                    array[j] = temp;
                }
            }
        }
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 11. <span id="链表中倒数第k个结点">链表中倒数第k个结点-链表</span>

1. **题目描述**: 
输入一个链表，输出该链表中倒数第k个结点。

2. **解题思路**: 
经典的双指针法。定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1步，第二个指针保持不动，从第k步开始，第二个指针也开始从链表的头指针开始遍历，由于两个指针的距离保持在k-1，当第一个指针到达链表的尾节点时，第二个指针刚好指向倒数第k个节点。

3. **关注要点**:
	1. 链表头指针是否为空，若为空则直接返回回null
	2. k是否为0，k为0也就是要查找倒数第0个节点，由于计数一般是从1开始的，所有输入0没有实际意义，返回null
	3. k是否超出链表的长度，如果链表的节点个数少于k，则在指针后移的过程中会出现next指向空指针的错误，所以程序中要加一个判断

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_11 {
    public ListNode FindKthToTail(ListNode head, int k) {
        if (head == null || k == 0) {
            return null;
        }
        ListNode temp = head;
        // 判断k是否超出节点数
        for(int i=0; i < k-1; i++){
            if(temp.next != null)
                temp = temp.next;
            else
                return null;
        }
        ListNode pA = head;
        ListNode pB = head;
        for (int i = 0; i < k -1; i++) {
            pA = pA.next;
        }
        // pA移动到从前数第k个节点，然后和pB一起向后移，直到结尾
        while (pA.next != null) {
            pA = pA.next;
            pB = pB.next;
        }
        return pB;
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 12. <span id="反转链表">反转链表-链表</span>

1. **题目描述**: 
输入一个链表，反转链表后，输出新链表的表头。

2. **解题思路**: 
设置三个指针，head为当前节点，pre为当前节点的前一个节点，next为当前节点的下一个节点，需要pre和next的目的是让当前节点从pre->head->next1->next2变成pre<-head next1->next2的过程中，用pre让节点反转所指方向，next节点保存next1节点防止链表断开

3. **需要注意的点**：
	1、如果输入的头结点是null，则返回null
	2、链表断裂的考虑
	
<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_12 {
    public ListNode ReverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        } 
        // 得到当前节点的下一个节点
        ListNode nextNode = head.next;
        // 打断当前指针链
        head.next = null;
        // 每次递归下一节点进行反转
        ListNode reList = ReverseList(nextNode);
        // 反转指针域
        nextNode.next = head;
        return reList;
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 13. <span id="合并两个排序的链表">合并两个排序的链表-链表</span>

1. **题目描述**: 
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

2. **解题思路**: 
两种解法：递归和非递归

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_13 {
    public ListNode Merge(ListNode list1, ListNode list2) {
        if (list1 == null) {
            return list2;
        } else if (list2 == null) {
            return list1;
        }
        // 设置合并列表头
        ListNode mergehead = null;
        if (list1.val < list2.val) {
            mergehead = list1;
            mergehead.next = Merge(list1.next, list2);
        } else {
            mergehead = list2;
            mergehead.next = Merge(list1, list2.next);
        }
        return mergehead;
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 14. <span id="树的子结构">树的子结构-树</span>

1. **题目描述**: 
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

2. **解题思路**: 
递归思想，如果根节点相同则递归调用IsSubtree()，如果根节点不相同，则判断root1的左子树和roo2是否相同，再判断右子树和root2是否相同;
注意节点为空的条件，HasSubTree中，只要有树为空就返回false; IsSubtree中，要先判断root2，如果root2为空，则说明第二棵树遍历完了，即匹配成功。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_14 {
    public boolean HasSubtree(TreeNode root1, TreeNode root2) {
        if (root1 == null || root2 == null) {
            return false;
        }
        return IsSubtree(root1, root2) 
        	|| HasSubtree(root1.left, root2)
        	|| HasSubtree(root1.right, root2);
    }
    public boolean IsSubtree(TreeNode root1, TreeNode root2) {
        if (root2 == null) {
            return true;
        }
        if (root1 == null) {
            return true;
        }
        if (root1.val == root2.val) {
            return IsSubtree(root1.left, root2.left) 
                && IsSubtree(root1.right, root2.right);
        } else {
            return false;
        }
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 15. <span id="二叉树的镜像">二叉树的镜像-树</span>

1. **题目描述**:
操作给定的二叉树，将其变换为源二叉树的镜像。

2. **输入描述**:
二叉树的镜像定义：

```
     源二叉树 
        8
       /  \
      6   10
     / \  / \
    5  7 9 11
    镜像二叉树
        8
       /  \
      10   6
     / \  / \
    11 9 7   5
```
3. **解题思路**: 
通过对以上两棵树的观察，我们可以总结出这两棵树的根节点相同，但它们的左、右两个子节点交换了位置。所以我们可以得出求一棵树的镜像的过程：先前序遍历这棵树的每个节点，如果遍历到的节点有子节点，就交换它的两个子节点。当交换完所有非叶节点的左、右子节点之后，就得到了树的镜像。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_15 {
    public void Mirror(TreeNode root) {
        // 若字节点为空，直接返回
        if (root == null) {
            return;
        }
        if (root.left == null && root.right == null) {
            return;
        }
        // 交换
        TreeNode temp = root.left;
        temp.left = root.right;
        root.right = temp;
        // 递归交换
        if (root.left != null) {
            Mirror(root.left);
        }
        if (root.right != null) {
            Mirror(root.right);
        }
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 16. <span id="顺时针打印矩阵">顺时针打印矩阵-数组</span>

1. **题目描述**:
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： `1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16` 则依次打印出数字`1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.`

2. **解题思路**:
	* 先得到矩阵的行和列数，然后依次旋转打印数据，一次旋转打印结束后，往对角分别前进和后退一个单位。
	* 要注意单行和单列的情况。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_16 {
    public ArrayList<Integer> printMatrix(int[][] matrix) {
        int row = matrix.length;
        int col = matrix[0].length;
        ArrayList<Integer> res = new ArrayList<>();
        if (row == 0 && col == 0) {
            return res;
        }
        int left = 0;
        int right = col -1;
        int top = 0;
        int bottom = row - 1;
        while (left <= right && top <= bottom) {
            // 上：左 到 右
            for (int i = left; i <= right; i++) {
                res.add(matrix[top][i]);
            }
            // 右：上 到 下
            for (int i = top + 1; i <= bottom; i++) {
                res.add(matrix[i][right]);
            }
            // 下：右 到 左
            if (top != bottom) {
                // 防止单行
                for (int i = right - 1; i >= left; i--) {
                    res.add(matrix[bottom][i]);
                }
            }
            // 左：从下到上
            if (left != right) {
                // 防止单列情况
                for (int i = bottom - 1; i > top; i--) {
                    res.add(matrix[i][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return res;
    }
}
```
</code></pre>
</details>	


- [backup](#1)

<HR>

#### 17. <span id="包含min函数的栈">包含min函数的栈-栈</span>

1. **题目描述**:
定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。

2. **解题思路**:
用一个栈stack保存数据，用另外一个栈temp保存依次入栈最小的数<br/>
比如，stack中依次入栈<br/>
`5, 3, 4, 10, 2, 12, 1, 8`<br/>
则temp依次入栈<br/>
`5, 3, 3，3, 2, 2, 1, 1`<br/>
每次入栈的时候，如果入栈的元素比min中的栈顶元素小或等于则入栈，否则用最小元素入栈。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_17 {
    Stack<Integer> stack = new Stack<>();
    Stack<Integer> temp = new Stack<>();
    int min = Integer.MAX_VALUE;
    public void push(int node) {
        stack.push(node);
        if (node < min) {
            temp.push(node);
            min = node;
        } else {
            temp.push(min);
        }
    }
    public void pop() {
        stack.pop();
        temp.pop();
    }
    public int top() {
        return stack.peek();
    }
    public int min() {
        return temp.peek();
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 18. <span id="栈的压入、弹出序列">栈的压入、弹出序列-栈</span>

1. **题目描述**: 
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

2. **解题思路**:
模拟堆栈操作的过程，将原数列依次压栈，把栈顶元素与所给出栈队列相比，如果相同则出栈，如果不同则继续压栈，直到原数列中所有数字压栈完毕。最后，检测栈中是否为空，若空，说明出栈队列可由原数列进行栈操作得到。否则，说明出栈队列不能由原数列进行栈操作得到。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_18 {
	public boolean IsPopOrder(int[] pushA, int[] popA) {
		if (pushA.length != popA.length ||
				pushA.length == 0 || popA.length == 0) {
			return false;
		}
		Stack<Integer> stack = new Stack();
		int index = 0;
		for (int i = 0; i < pushA.length; i++) {
			stack.push(pushA[i]);
			while (!stack.empty() && stack.peek() == popA[index]) {
				stack.pop();
				index++;
			}
		}
		return stack.empty();
	}
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 19. <span id="从上往下打印二叉树">从上往下打印二叉树-树</span>

1. **题目描述**:
从上往下打印出二叉树的每个节点，同层节点从左至右打印。

2. **解题思路**: 
	* 就是二叉树的层序遍历。借助一个队列就可以实现。
	* 使用两个队列一个存放节点，一个存放值。先将根节点加入到队列中，然后遍历队列中的元素，遍历过程中，访问该元素的左右节点，再将左右子节点加入到队列中来。
	* 注意Queue创建的方式：Queue<TreeNode> queue = new LinkedList<TreeNode>();
	* 用add将元素添加到队列中，用remove来移除并返回队首元素。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_18 {
    public boolean isPopOrder(int[] pushA, int[] popA) {
        if (pushA.length != popA.length
            || pushA.length == 0
            || popA.length == 0) {
                return false;
        }
        Stack<Integer> stack = new Stack<>();
        int index = 0;
        for (int i = 0; i < pushA.length; i++) {
            stack.push(pushA[i]);
            while (!stack.empty() && stack.peek() == popA[index]) {
                stack.pop();
                index++;
            }
            return stack.empty();
        }
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 20. <span id="二叉搜索树的后序遍历序列">二叉搜索树的后序遍历序列-树</span>

1. **题目描述**：
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

2. **解题思路**：
	* 二叉搜索树: 左子树<根<=右子树<br/>
	* 对于后序遍历来说，序列数组的最后一个元素一定是根节点, 根据这个元素，将前面的数组分为左、右两个部分，左侧部分都比该元素小，右侧部分都比该元素大，如果右侧部分有比该根节点小的元素，那么就不是后序遍历，如此递归进行。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_20 {
    public boolean verifySquenceOfBST(int[] sequence) {
        if (sequence.length == 0) {
            return false;
        } 
        if (sequence.length == 1) {
            return true;
        }
        return judge(sequence, 0, sequence.length - 1);
    }
    public boolean judge(int[] sequence, int start, int root) {
        // 这个是递归的终点
        if (start >= root) {
            return true;
        }
        int i = start;
        while (i < root && sequence[i] < sequence[root]) {
            i++;
        }
        // 这里判断如果右子树中的元素要是存在小于根节点的，那么就不是后序遍历
        for (int j = i; j < root; j++) {
            if (sequence[j] < sequence[root]) {
                return false;
            }
        }
        // 接着将左子树和右子树分别递归检查
        return (judge(sequence, start, i - 1) && judge(sequence, i, root - 1));
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 21. <span id="二叉树中和为某一值的路径">二叉树中和为某一值的路径-树</span>

1. **题目描述**：
输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。

2. **解题思路**：
用前序遍历的方式访问到某一结点时，把该结点添加到路径上，并用目标值减去该节点的值。如果该结点为叶结点并且目标值减去该节点的值刚好为0，则当前的路径符合要求，我们把加入res数组中。如果当前结点不是叶结点，则继续访问它的子结点。当前结点访问结束后，递归函数将自动回到它的父结点。因此我们在函数退出之前要在路径上删除当前结点，以确保返回父结点时路径刚好是从根结点到父结点的路径。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_21 {
    ArrayList<ArrayList<Integer>> res = new ArrayList<>();
    ArrayList<Integer> temp = new ArrayList<>();
    public ArrayList<ArrayList<Integer>> findPath(TreeNode root, int target) {
        // 这里是递归结束条件
        if (root == null) {
            return res;
        }
        target -= root.val;
        temp.add(root.val);
        // 这里是递归结束条件
        if (target == 0 && root.left == null && root.right == null) {
            res.add(new ArrayList<Integer>(temp));
        } else {
            findPath(root.left, target);
            findPath(root.right, target);
        }
        temp.remove(temp.size() - 1);
        return res;
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 22. <span id="复杂链表的复制">复杂链表的复制-链表</span>

1. **题目描述**：
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_22 {
    public RandomListNode Clone(RandomListNode pHead) {
        if (pHead == null) {
            return null;
        }
        // 复制节点 A->B->C 变成 A-A'->B->B'->C->C'
        RandomListNode head = pHead;
        while (head != null) {
            RandomListNode node = new RandomListNode(head.label);
            node.next = head.next;
            head.next = node;
            head = node.next;
        }
        // 复制random
        head = pHead;
        while (head != null) {
            head.next.random = head.random == null ? null : head.random.next;
            head = head.next.next;
        }
        // 拆分
        head = pHead;
        RandomListNode chead = head.next;
        while (head != null) {
            RandomListNode node = head.next;
            head.next = node.next;
            node.next = node.next == null ? null : node.next.next;
            head = head.next;
        }
        return chead;
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 23. <span id="二叉搜索树与双向链表">二叉搜索树与双向链表-树、链表</span>

1. **题目描述**：
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

2. **解题思路**：题目可能比较难理解，可以看如下的图，我们有一棵二叉搜索树，要求得右边的双向链表。
	* 在二叉搜索树中，左子结点的值总是小于父结点的值，右子节点的值总是大于父结点的值。因此我们在转换成排序双向链表时，原先指向左子结点的指针调整为链表中指向前一个结点的指针，原先指向右子节点的指针调整为链表中指向后一个结点的指针。
	* 因为中序遍历是按照从小到大的顺序遍历二叉搜索树，所以我们用中序遍历树中的每一个节点得到的正好是要求的排好序的。遍历过程如下：
	* 每次遍历节点的左孩子、右孩子，把左孩子指向转换链表的尾节点，并把末尾指针的右孩子指向自己。右孩子指向节点的右孩子。如果没有右孩子就返回。这一过程可以用递归实现。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_23 {
    TreeNode head = null;
    TreeNode end = null;
    public TreeNode Convert(TreeNode pRootOfTree) {
        ConvertSub(pRootOfTree);
        return head;
    }
    public void ConvertSub(TreeNode pRootOfTree) {
        if (pRootOfTree == null) {
            return;
        }
        Convert(pRootOfTree.left);
        if (end == null) {
            head = pRootOfTree;
            end = pRootOfTree;
        } else {
            end.right = pRootOfTree;
            pRootOfTree.left = end;
            end = pRootOfTree;
        }
        Convert(pRootOfTree.right);
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 24. <span id="字符串的排列">字符串的排列-字符串</span>

1. **题目描述**：
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

2. **输入描述**：
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。

3. **解题思路**：
刚看题目的时候，可能会觉得这个问题很复杂，不能一下子想出解决方案。那我们就要学会把复杂的问题分解成小问题。我们求整个字符串的排列，其实可以看成两步
	1. 第一步求所有可能出现在第一个位置的字符（即把第一个字符和后面的所有字符交换[相同字符不交换]）；
	2. 第二步固定第一个字符，求后面所有字符的排列。这时候又可以把后面的所有字符拆成两部分（第一个字符以及剩下的所有字符），依此类推。这样，我们就可以用递归的方法来解决。

<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.ArrayList;
import java.util.Collections;
public class Solution_24 {
    ArrayList<String> res = new ArrayList<>();
    public ArrayList<String> Permutation(String str) {
        if (str == null) {
            return res;
        }
        PermutationHelper(str.toCharArray(), 0);
        Collections.sort(res);
        return res;
    }
    // 递归函数
    public void PermutationHelper(char[] str, int i) {
        if (i == str.length - 1) {  
            res.add(String.valueOf(str));
        } else {
            for (int j = i; j < str.length; j++) {
                if (j != i && str[i] == str[j]) {
                    // 相同的字母就跳过
                    continue;
                }
                swap(str, i, j);
                PermutationHelper(str, i + 1);
                swap(str, i, j);
            }
        }
    }
    // 交换元素
    public void swap(char[] str, int i, int j) {
        char temp = str[i];
        str[i] = str[j];
        str[j] = temp;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 25. <span id="数组中出现次数超过一半的数字">数组中出现次数超过一半的数字-数组</span>

1. **题目描述**：
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

2. **解题思路**：三种解法
	* 法1：借助hashmap存储数组中每个数出现的次数，最后看是否有数字出现次数超过数组长度的一半；
	* 法2：排序。数组排序后，如果某个数字出现次数超过数组的长度的一半，则一定会数组中间的位置。所以我们取出排序后中间位置的数，统计一下它的出现次数是否大于数组长度的一半；
	* 法3：某个数字出现的次数大于数组长度的一半，意思就是它出现的次数比其他所有数字出现的次数和还要多。因此我们可以在遍历数组的时候记录两个值：1. 数组中的数字;2. 次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。最后再判断它是否符合条件。

<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.Arrays;
public class Solution_25 {
    public int moreThanHalfNum(int[] array) {
        if (array.length == 0) {
            return 0;
        }
        // 没确定是否已经排序，排序了的话就不用了
        Arrays.sort(array);
        // 直接取数组中一半的那个值，要是这个值的长度超出数组的一半
        // 一半的值中怎么也会有这个值，然后计算这个值数量是否超出一半就好
        int half = array.length /2;
        int count = 0;
        for (int i = 0; i < array.length; i++) {
            if (array[i] == array[half]) {
                count++;
            }
        }
        if (count > half) {
            return array[half];
        }
        return 0;
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 26. <span id="最小的K个数">最小的K个数-数组</span>

1. **题目描述**：
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。

2. **解题思路**：两种方法
	* 法1：先对数组排序，然后取出前k个
	* 法2：利用最大堆保存这k个数，每次只和堆顶比，如果比堆顶小，删除堆顶，新数入堆。

<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.ArrayList;
import java.util.Arrays;
public class Solution_26 {
    public ArrayList<Integer> GetLeastNumbers(int[] input, int k) {
        ArrayList<Integer> res = new ArrayList<>();
        if (k == 0 || input.length == 0 || k > input.length) {
            return res;
        }
        Arrays.sort(input);
        for (int i = 0; i < k; i++) {
            res.add(input[i]);
        }
        return res;
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 27. <span id="连续子数组的最大和">连续子数组的最大和-数组</span>

1. **题目描述**：
HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)

2. **解题思路**：
对于一个数组中的一个数x，若是x的左边的数加起来非负，那么加上x能使得值变大，这样我们认为x之前的数的和对整体和是有贡献的。如果前几项加起来是负数，则认为有害于总和。
我们用cur记录当前值, 用max记录最大值，如果cur<0,则舍弃之前的数，让cur等于当前的数字，否则，cur = cur+当前的数字。若cur和大于max更新max。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_27 {
    public int findGreatestSumOfSubArray(int[] array) {
        if (array.length == 0) {
            return 0;
        }
        int cur = array[0];
        int max = 0;
        for (int i = 0; i < array.length; i++) {
            // cur是累加的临时和
            cur = cur > 0 ? cur + array[i] : array[i];
            if (max < cur) {
                max = cur;
            }
        }
        return max;
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 28. <span id="整数中1出现的次数">整数中1出现的次数(从1到n整数中1出现的次数)-数组</span>

1. **题目描述**: 
求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

2. **解题思路**: 
三种解法：<br/>
	* 法一：依次遍历每个数，判断每个数里面是否包含1
	* 法二：同法一，将数字转成字符串，直接判断
	* 法三：归纳法<br/>设N = abcde ,其中abcde分别为十进制中各位上的数字；<br/>如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。
		1. 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100~199，1100~1199,2100~2199，，…，11100~11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。
		2. 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100~199，1100~1199,2100~2199，，….，11100~11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100~12113,一共114个，等于低位数字（113）+1。
		3. 如果百位上数字大于1（2~9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100~199,1100~1199，2100~2199，…，11100~11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_28 {
    public int NumberOf1Between1AndN(int n) { 
        int res = 0;
        for (int i = 0; i < n; i++) {
            res += number(i);
        }
        return res;
    }
    public int number(int n) {
        int res = 0;
        while (n > 0) {
            if (n % 10 == 1) {
                res++;
            }
            n /= 10;
        }
        return res;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 29. <span id="把数组排成最小的数">把数组排成最小的数-数组</span>

1. **题目描述**
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

2. **解题思路**
	* 先将数组转换成字符串数组，然后对字符串数组按照规则排序，最后将排好序的字符串数组拼接出来。
	* 关键就是制定排序规则：<br/>
		若ab > ba 则 a > b<br/>
		若ab < ba 则 a < b<br/>
		若ab = ba 则 a = b<br/>
	* 解释说明：<br/>
	a = 21<br/>
	b = 2<br/>
	因为 212 < 221, 即 ab < ba ，所以 a < b<br/>
	所以我们通过对ab和ba比较大小，来判断a在前或者b在前的。<br/>

<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.Arrays;
import java.util.Comparator;
public class Solution_29 {
    public String PrintMinNumber(int [] numbers) {
        int len = numbers.length;
        if (len == 0) {
            return "";
        } else if (len == 1) {
            return String.valueOf(numbers[0]);
        }
        StringBuilder res = new StringBuilder();
        String[] str = new String[len];
        for (int i = 0; i < len; i++) {
            str[i] = String.valueOf(numbers[i]);
        }
        // 这里是灵魂，一定要要加比对器，因为'abc'和'ab'是比对不出来的
        Arrays.sort(str, new Comparator<String>() {
            public int compare(String s1, String s2) {
                String c1 = s1 + s2;
                String c2 = s2 + s1;
                return c1.compareTo(c2);
            }
        });
        for (int i = 0; i < len; i ++) {
            res.append(str[i]);
        }
        return res.toString();
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 30. <span id="丑数">丑数-数值</span>

1. **题目描述**: 
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

2. **解题思路**: 
	* 判断一个数是不是丑数，最简单的方法就是让这个数不断除以2，3，5。要求第N个丑数，只要从1开始，依次判断每个数是不是丑数，如果是，则相应的序号加1，直到序号为N，就是我们要的丑数了。但是这种方法时间效率很，通常面试官不会满意这样的答案。因此我们需要一个时间复杂度更低的解法。
	* 换个思路，我们只求丑数，不要去管非丑数。每个丑数必然是由小于它的某个丑数乘以2，3或5得到的，这样我们把求得的丑数都保存下来，用之前的丑数分别乘以2，3，5，找出这三这种最小的并且大于当前最大丑数的值，即为下一个我们要求的丑数。这种方法用空间换时间，时间复杂度为O(n)。


<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_30 {
    public int getUglyNumber(int index) {
        if (index <= 0) {
            return 0;
        }
        if (index == 1) {
            return 1;
        }
        int t2 = 0;
        int t3 = 0;
        int t5 = 0;
        int[] res = new int[index];
        res[0] = 1;
        // 这个都是基于1得来的丑数，res的集合都是丑数
        for (int i = 1; i < index; i++) {
            res[i] = Math.min(res[t2] * 2, Math.min(res[t3] * 3, res[t5] * 5));
            // 后面复制的都是前面的丑数*新的因子，是永远不可能出现非丑数的
            if (res[i] == res[t2] * 2) t2++;
            if (res[i] == res[t3] * 3) t3++;
            if (res[i] == res[t5] * 5) t5++; 
        }
        return res[index - 1];
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 31. <span id="第一个只出现一次的字符">第一个只出现一次的字符-字符串</span>

1. **题目描述**: 
在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1.

2. **解题思路**: 
先在hash表中统计各字母出现次数，第二次扫描直接访问hash表获得次数。也可以用数组代替hash表。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_31 {
    public static int firstNotRepeatingChar(String str) {
        if (str.length() == 0) {
            return -1;
        }
        char[] s = str.toCharArray();
        int[] m = new int[256];
        // 第一次循环，将每个字符ASSII位置，添加出现的次数
        for (int i = 0; i < str.length(); i++) {
            m[s[i]]++;
        }
        // 第二次循环，将第一个s[i]数量为1的返回
        for (int i = 0; i < str.length(); i++) {
            if (m[s[i]] == 1) {
                return i;
            }
        }
        return -1;
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 32. <span id="数组中的逆序对">数组中的逆序对-数组</span>

1. **题目描述**: 
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
2. **输入描述**:
题目保证输入的数组中没有的相同的数字

3. **数据范围**：
	* 对于%50的数据,size<=10^4
	* 对于%75的数据,size<=10^5
	* 对于%100的数据,size<=2*10^5

4. **示例1**：输入：`1,2,3,4,5,6,7,0`， 输出：`7`

5. **解题思路**：很容易想到的方法就是遍历每一个元素，让其与后面的元素对比，如果大于则count++，但是这样的时间复杂度是O(n^2)，因此，我们可以用归并排序思路。
	* 例如7,5,4,6可以划分为两段7,5和4,6两个子数组
	* 在7,5中求出逆序对，因为7大于5所以有1对
	* 在6,4中求出逆序对，因为6大于4所以逆序对再加1，为2
	* 对7,5和6,4进行排序，结果为5,7,和4,6
	* 设置两个指针分别指向两个子数组中的最大值，p1指向7，p2指向6
	* 比较p1和p2指向的值，如果大于p2，因为p2指向的是最大值，所以第二个子数组中有几个元素就有几对逆序对(当前有两个元素，逆序对加2,2+2=4)，7>6,比较完之后将p1指向的值放入辅助数组里，辅助数组里现在有一个数字7，然后将p1向前移动一位指向5
	* 再次判断p1和p2指向的值，p1小于p2，因为p1指向的是第一个子数组中最大值，所以子数组中没有能和当前p2指向的6构成逆序对的数，将p2指向的值放入辅助数组，并向前移动一位指向4，此时辅助数组内为6,7
	* 继续判断p1(指向5)和p2(指向4)，5>4,第二个子数组中只有一个数字，逆序对加1，4+1=5，为5对，然后将5放入辅助数组，第一个子数组遍历完毕，只剩下第二个子数组，当前只有一个4，将4也放入辅助数组，函数结束。辅助数组此时为4,5,6,7.逆序对为5.

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution {
    public int InversePairs(int [] array) {
        int len = array.length;
        if(array== null || len <= 0){
            return 0;
        }
        return mergeSort(array, 0, len-1);
    }
    public int mergeSort(int [] array, int start, int end){
        if(start == end)
            return 0;
        int mid = (start + end) / 2;
        int left_count = mergeSort(array, start, mid);
        int right_count = mergeSort(array, mid + 1, end);
        int i = mid, j = end;
        int [] copy = new int[end - start + 1];
        int copy_index = end - start;
        int count = 0;
        while(i >= start && j >= mid + 1){
            if(array[i] > array[j]){
                copy[copy_index--] = array[i--];
                count += j - mid;
                if(count > 1000000007){
                    count %= 1000000007;
                }
            }else{
                copy[copy_index--] = array[j--];
            }
        }
        while(i >= start){
            copy[copy_index--] = array[i--];
        }
        while(j >= mid + 1){
            copy[copy_index--] = array[j--];
        }
        i = 0;
        while(start <= end) {
            array[start++] = copy[i++];
        }
        return (left_count+right_count+count)%1000000007;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 33. <span id="两个链表的第一个公共结点">两个链表的第一个公共结点-链表</span>

1. **题目描述**：
输入两个链表，找出它们的第一个公共结点。

2. **解题思路**：
	* 如果两个链表存在公共结点，那么它们从公共结点开始一直到链表的结尾都是一样的，因此我们只需要从链表的结尾开始，往前搜索，找到最后一个相同的结点即可。但是题目给出的单向链表，我们只能从前向后搜索，这时，我们就可以借助栈来完成。先把两个链表依次装到两个栈中，然后比较两个栈的栈顶结点是否相同，如果相同则出栈，如果不同，那最后相同的结点就是我们要的返回值。
	* 还有一种方法，不需要借助栈。先找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走，直到找到第一个公共结点。


<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_33 {
    // 如果两个单链表，那么两个单链表的公共节点开始，
    // 两个链表就重合了，那么一直到后面链表末尾，就都是一样的了
    public ListNode findFirstCommonNode(ListNode pHead1, ListNode pHead2) {
        Stack<ListNode> s1 = new Stack<>();
        Stack<ListNode> s2 = new Stack<>();
        while (pHead1 != null) {
            s1.push(pHead1);
            pHead1 = pHead1.next;
        }
        while (pHead2 != null) {
            s2.push(pHead2);
            pHead2 = pHead2.next;
        }
        ListNode res = null;
        while (!s1.isEmpty() && !s2.isEmpty() && s1.peek() == s2.peek()) {
            s1.pop();
            // 这里就是res是最后一组两个栈内相等的元素，也就是第一个公共节点
            res = s2.pop();
        }
        return res;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 34. <span id="数字在排序数组中出现的次数">数字在排序数组中出现的次数-数组</span>

1. **题目描述**：
统计一个数字在排序数组中出现的次数。

2. **解题思路**：
	* 正常的思路就是二分查找了，我们用递归的方法实现了查找k第一次出现的下标，用循环的方法实现了查找k最后一次出现的下标。
	* 除此之外，还有另一种奇妙的思路，因为data中都是整数，所以我们不用搜索k的两个位置，而是直接搜索k-0.5和k+0.5这两个数应该插入的位置，然后相减即可。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_34 {
    public int GetNumberOfK(int [] array , int k) {
        int len = array.length;
        if (len == 0) {
            return 0;
        }
        // 利用二分法查找这个数字出现的第一个位置和第最后一个位置
        int first = getFirst(array, k, 0, len - 1);
        int last = getLast(array, k, 0, len -1);
        if (first != -1 && last != -1) {
            return last - first + 1;
        }
        return 0;
    }
    public int getFirst(int[] array, int k, int start, int end) {
        int mid;
        while (start <= end) {
            mid = start + (end - start) / 2;
            if (k <= array[mid]) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        if (start < array.length && array[start] == k) {
            return start;
        } else {
            return -1;
        }
    }
    // 循环
    public int getLast(int[] array, int k, int start, int end) {
        int mid;
        while (start <= end) {
            mid = start + (end - start) / 2;
            if (k >= array[mid]) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        if (end >= 0 && array[end] == k) {
            return end;
        } else {
            return -1;
        }
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 35. <span id="二叉树的深度">二叉树的深度-树</span>

1. **题目描述**：
输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

2. **解题思路**：
	* 法一：递归法。求二叉树的深度，就是求左子树、右子树的中深度最大的加上一个根节点，依此递归即可。
	* 法二：层次遍历。每遍历一层，deep 加 1，直接到最后一层，输出 deep。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_35 {
    public int treeDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int left = treeDepth(root.left) + 1;
        int right = treeDepth(root.right) + 1;
        return left > right ? left : right;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 36. <span id="数组中只出现一次的数字">数组中只出现一次的数字-数组</span>

1. **题目描述**：
一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。

2. **解题思路**：
	* 法一：大家都能想到的HashMap法
	* 法二：异或法
		1. 任何一个数字异或它自己都等于0。
		2. 如果数组中只一个数字是只出现一次的，其他数字都是成双成对出现的，那么我们从头到尾依次异或数组中的每个数字，最终的结果刚好就是那个只出现一次的数字，因为那些成对出现两次的数字全部在异或中抵消了。
		3. 那么回到我们的题目，因为有两个只出现一次的数字，所以我们可以试着把原数组分成两个子数组，使得每个数组包含一个只出现一次的数字，而其他数字都成对出现两次。如果这样拆分成两个数组，那么我们就可以按照之前的办法分别对两个数组进行异或运算找出两个只出现一次的数字。
		4. 问题来了，如何进行分组呢？
		5. 我们还是从头到尾依次异或数组中的每个数字，那么最终得到的结果就是两个只出现一次的数字异或的结果。由于这两个数字不一样，所以异或的结果至少有一位为1，我们在结果数字中找到第一个为1的位置，记为index位，现在我们以第index位是不是1为标准把原数组拆分成两个子数组，第一个子数组中的数组第index位都为1，第二个子数组中的数组第index位都为0，那么只出现一次的数字将被分配到两个子数组中去，于是每个子数组中只包含一个出现一次的数字，而其他数字都出现两次。这样我们就可以用之前的方法找到数组中只出现一次的数字了。

<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.HashMap;
public class Solution_36 {
    public void findnumbersAppearOnce(int[] array, int[] num1, int[] num2) {
        HashMap<Integer, Integer> temp = new HashMap<>();
        for (int i = 0; i < array.length; i++) {
            if (temp.containsKey(array[i])) {
                // 因为出现一次的元素，不可能再次被移除，只能添加一次
                temp.remove(array[i]);
            } else {
                temp.put(array[i], 1);
            }
        }
        int[] a = new int[array.length];
        int i = 0;
        for (Integer k : temp.keySet()) {
            a[i] = k;
            i++;
        }
        num1[0] = a[0];
        num2[0] = a[1];
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 37. <span id="和为S的两个数字">和为S的两个数字-数值</span>

1. **题目描述**：
输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。

2. **解题思路**：
	* 法一：哈希法。用一个HashMap，它的 key 存储数S与数组中每个数的差，value 存储当前的数字，比较S=15, 当前的数为 4，则往 hashmap 中插入(key=11, value=4)。我们遍历数组，判断hashmap 中的 key 是否存在当前的数字，如果存在，说明存在着另一个数与当前的数相加和为 S，我们就可以判断它们的乘积是否小于之前的乘积，如果小的话就替换之前的找到的数字，如果大就放弃当前找到的。如果hashmap 中的 key 不存在当前的数字，说明还没有找到相加和为 S 的两个数，那就把S与当前数字的差作为 key，当前数字作为 value 插入到 hashmap 中，继续遍历。
	* 法二：左右夹逼的方法。a+b=sum，a和b越远乘积越小，因为数组是递增排序，所以一头一尾两个指针往内靠近的方法找到的就是乘积最小的情况。
		1. 若ai + aj == sum，就是答案（相差越远乘积越小）
		2. 若ai + aj > sum，说明 aj 太大了，j —
		3. 若ai + aj < sum，说明 ai 太小了，i ++

<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.ArrayList;
public class Solution_37 {
    // 左右夹逼法则
    public ArrayList<Integer> findNumberWithSum(int[] array, int sum) {
        ArrayList<Integer> res = new ArrayList<>();
        if (array.length < 2) {
            return res;
        }
        int i = 0;
        int j = array.length - 1;
        while (i != j) {
            if (array[i] + array[j] == sum) {
                res.add(array[i]);
                res.add(array[j]);
                break;
            } else if (array[i] + array[j] < sum) {
                i++;
            } else {
                j++;
            }
        } 
        return res;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 38. <span id="和为S的连续正数序列">和为S的连续正数序列-数值</span>

1. **题目描述**：
小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!

2. **解题思路**：
滑动窗口的方法：用两个数字 start 和 end 分别表示序列的最小值和最大值，首先将 start 初始化为1，end 初始化为2。如果从start到end的和大于sum，我们就从序列中去掉较小的值(即增大start),
	* 相反，只需要增大end。
	* 终止条件为：一直增加begin到(1+sum)/2并且end小于sum为止

<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.ArrayList;
public class Solution_38 {
    public ArrayList<ArrayList<Integer>> findCoutinuousSequence(int sum) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();
        if (sum < 3) {  // 50 + 51 || 49 + 50 都不行
            return res;
        }
        int start = 1;
        int end = 2;
        int mid = (1 + sum) / 2;
        while (start < mid) {
            int s = totalSum(start, end);
            if (s == sum) {
                res.add(getSequence(start, end));
                end++;
            } else if (s < sum) {
                end++;
            } else if (s > sum) {
                start++;
            }
        }
        return res;
    }
    // 计算从开始到结束的总和值
    public int totalSum(int start, int end) {
        int sum = 0;
        for (int i = start; i <= end; i++) {
            sum += i;
        }
        return sum;
    }
    // 将符合条件的添加到一个list中
    public ArrayList<Integer> getSequence(int start, int end) {
        ArrayList<Integer> temp = new ArrayList<>();
        for (int i = start; i <= end; i++) {
            temp.add(i);
        }
        return temp;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 39. <span id="翻转单词顺序列">翻转单词顺序列-字符串</span>

1. **题目描述**：
牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一翻转这些单词顺序可不在行，你能帮助他么？

2. **解题思路**：
很简单的题，也没啥好说的，注意一下测试用例为全是空格的情况：” ”
	* trim() : 去除字符串首尾空格
	* split() : 对字符串按照所传参数进行分割

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_39 {
    public String reverseSentence(String str) {
        if (str.trim().length() == 0) {
            return str;
        }
        // 除去空格，变成数组
        String[] temp = str.split(" ");
        String res = "";
        // 从后往前遍历，除了最后一个后面不加空格之外
        for (int i = temp.length - 1; i >= 0; i--) {
            res += temp[i];
            if (i != 0) {
                res += " ";
            }
        }
        return res;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 40. <span id="左旋转字符串">左旋转字符串-字符串</span>

1. **题目描述**：
汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！

2. **解题思路**：
很简单的题，在第 n 个字符后面将切一刀，将字符串分为两部分，再重新并接起来即可。注意字符串长度为 0 的情况。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_40 {
    public String leftRotateString(String str, int n) {
        int len = str.length();
        if (len == 0) {
            return "";
        }
        // 这里避免了n=0的情况，其实应该添加if判断 n > 0的情况
        n = n % len;
        String s1 = str.substring(n, len);
        String s2 = str.substring(0, n);
        return s1 + s2;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 41. <span id="扑克牌顺子">扑克牌顺子-数组</span>

1. **题目描述**：
LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。

2. **解题思路**：
先统计王(0)的数量，再把牌排序，如果后面一个数比前面一个数大于1以上，那么中间的差值就必须用王来补了。看王的数量够不够，如果够就返回true，否则返回false。

<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.Arrays;
public class Solution_41 {
    public boolean isContinuous(int[] numbers) {
        int zero = 0;   // 大王的数量
        int dis = 0;    // 消灭大王
        if (numbers.length != 5) {
            return false;
        }
        Arrays.sort(numbers);
        for (int i = 0; i < 4; i++) {
            if (numbers[i] == 0) {
                zero++;
                continue;
            }
            // 这里去除了前后相等的情况
            if (numbers[i] == numbers[i + 1]) {
                return false;
            }
            // 这里去除了后面比前面大很多的情况，不包括0，因为0的continue了
            if (numbers[i + 1] - numbers[i] > 1) {
                dis += numbers[i + 1] - numbers[i] - 1;
            }
        }
        // 缺少大王的数量够不够后一张和前一张的差距的
        if (zero >= dis) {
            return true;
        } else {
            return false;
        }
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 42. <span id="圆圈中最后剩下的数">孩子们的游戏(圆圈中最后剩下的数)-数组</span>

1. **题目描述**：
每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)

2. **解题思路**：
用环形链表模拟圆圈。创建一个总共有 n 个结点的环形链表，然后每次在这个链表中删除第 m 个结点。注意，起步是-1 不是 0。

<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.LinkedList;
public class Solution_42 {
    public int lastRemaining(int n, int m) {
        if (n < 1 || m < 1) {
            return -1;
        }
        LinkedList<Integer> link = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            link.add(i);
        }
        // 这里起步是-1，不是0，因为当m=0时，
        int index = -1;
        while (link.size() > 1) {
            // 
            index = (index + m) % link.size();
            link.remove(index);
            index--;
        }
        return link.get(0);
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 43. <span id="求1+2+3+…+n">求1+2+3+…+n-数值</span>

1. **题目描述**: 
求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

2. **解题思路**: 
	* 累加不能用循环的话，那就试试递归吧。
	* 判断递归的终止条件不能用 if 和 switch，那就用短路与代替。
	`(n > 0) && (sum += Sum_Solution(n-1))>0`，只有满足n > 0的条件，&&后面的表达式才会执行。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_43 {
    //
    public int sumResult(int n) {
        int sum = n;
        boolean t = (n > 0) && (sum += sumResult(n-1)) > 0;
        return sum;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 44. <span id="不用加减乘除做加法">不用加减乘除做加法-数值</span>

1. **题目描述**: 
写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

2. **解题思路**: 
用位运算来实现。
	* step1: 进行异或运算，计算两个数各个位置上的相加，不考虑进位；
	* step2: 进行位与运算，然后左移一位，计算进位值；
	* step3: 把异或运算的结果赋给 num1，把进位值赋给 num2，依此循环，进位值为空的时候结束循环，num1就是两数之和。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_44 {
    public int Add(int num1, int num2) {
        if (num2 == 0) {
            return num1;
        }
        int sum = 0;
        int carry = 0;
        while (num2 != 0) {
            // 将二进制中不同的相加，留下1
            sum = num1 ^ num2;
            // 将二进制中
            carry = (num1 & num2) << 1;
            num1 = sum;
            num2 = carry;
        }
        return num1;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 45. <span id="把字符串转换成整数">把字符串转换成整数-字符串</span>

1. **题目描述**: 
将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。

2. **解题思路**: 
常规思路，先判断第一位是不是符号位，如果有符号，有flag 做标记。
遍历字符串中的每个字符，如果存在非数字的字符，直接返回 0，否则，用当前字符减去’0’得到当前的数字，再进行运算。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_45 {
    public static int strToInt(String str) {
        if (str.length() == 0) {
            return 0;
        }
        int flag = 0;
        if (str.charAt(0) == '+') {
            flag = 1;
        } else if (str.charAt(0) == '-') {
            flag = 2;
        }
        int start = flag > 0 ? 1 : 0;
        long res = 0;
        while (start < str.length()) {
            if (str.charAt(start) > '9' || str.charAt(start) < '0') {
                return 0;
            }
            res = res * 10 + (str.charAt(start) - '0');
            start++;
        }
        return flag == 2 ? -(int)res : (int)res;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 46. <span id="数组中重复的数字">数组中重复的数字-数组</span>

1. **题目描述**: 
在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。

2. **解题思路**: 
最简单的就是用一个数组或者哈希表来存储已经遍历过的数字，但是这样需要开辟额外的空间。
如果题目要求不能开辟额外的空间，那我们可以用如下的方法：
	* 因为数组中的数字都在0~n-1的范围内，所以，如果数组中没有重复的数，那当数组排序后，数字i将出现在下标为i的位置。现在我们重排这个数组，从头到尾扫描每个数字，当扫描到下标为i的数字时，首先比较这个数字(记为m)是不是等于i。
	* 如果是，则接着扫描下一个数字；如果不是，则再拿它和m 位置上的数字进行比较，如果它们相等，就找到了一个重复的数字（该数字在下标为i和m的位置都出现了），返回true；
	* 如果它和m位置上的数字不相等，就把第i个数字和第m个数字交换，把m放到属于它的位置。接下来再继续循环，直到最后还没找到认为没找到重复元素，返回false。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_46 {
    public boolean duplicate(int[] numbers, int length, int[] duplication) {
        if (length == 0) {
            return false;
        }
        Arrays.sort(numbers);
        for (int i = 0; i < length - 1; i++) {
            if (numbers[i] == numbers[i + 1]) {
                duplication[0] = numbers[i];
                return true;
            }
        }
        return false;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 47. <span id="构建乘积数组">构建乘积数组-数组</span>

1. **题目描述**: 
给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素`B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]`。不能使用除法。

2. **解题思路**: 
B[i]的值可以看作图中矩阵第 i 行所有元素的乘积。我们可以先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_47 {
    public int[] multiply(int[] A) {
        if (A.length < 1) {
            return A;
        }
        int[] B = new int[A.length];
        B[0] = 1;
        for (int i = 1; i < A.length; i++) {
            B[i] = B[i - 1] * A[i - 1];
        }
        int temp = 1;
        for (int j = A.length - 2; j >= 0; j--) {
            temp *= A[j+1];
            B[j] *= temp;
        }
        return B;
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 48. <span id="正则表达式匹配">正则表达式匹配-字符串</span>

1. **题目描述**：
请实现一个函数用来匹配包括’.’和’\*’的正则表达式。模式中的字符’.’表示任意一个字符，而’\*’表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab\*ac\*a”匹配，但是与”aa.a”和”ab\*a”均不匹配

2. **解题思路**: 
	* 当模式中的第二个字符不是“\*”时：
		1. 如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。
		2. 如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。

	* 而当模式中的第二个字符是“\*”时：
如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式：
		1. 模式后移2字符，相当于x\*被忽略；
		2. 字符串后移1字符，模式后移2字符；
		3. 字符串后移1字符，模式不变，即继续匹配字符下一位，因为\*可以匹配多位。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_48 {
    public boolean match(char[] str, char[] pattern) {
        int sindex = 0;
        int pindex = 0;
        return matchCore(str, sindex, pindex, pattern);
    }
    public boolean matchCore(char[] str, int sindex, int pindex, char[] pattern) {
        if (sindex >= str.length && pindex == pattern.length) {
            return true;
        }
        if (pindex >= pattern.length && sindex < str.length) {
            return false;
        }
        if (pindex < pattern.length && pattern[pindex + 1] == '*') {
            if (sindex < str.length && (str[sindex] == pattern[pindex] || pattern[pindex] == '.')) {
                return matchCore(str, sindex, pindex + 2, pattern) ||
                    matchCore(str, sindex + 1, pindex + 2, pattern) ||
                    matchCore(str, sindex + 1, pindex, pattern);
            } else {
                return matchCore(str, sindex, pindex + 2, pattern);
            }
        }
        if (sindex < str.length && (str[sindex] == pattern[pindex] || pattern[pindex] == '.')) {
            return matchCore(str, sindex + 1, pindex + 1, pattern);
        }
        return false;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 49. <span id="表示数值的字符串">表示数值的字符串-字符串</span>

1. **题目描述**：
请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100″,”5e2″,”-123″,”3.1416″和”-1E-16″都表示数值。 但是”12e”,”1a3.14″,”1.2.3″,”+-5″和”12e+4.3″都不是。

2. **解题思路**：
	* 设置三个标志符分别记录“+/-”、“e/E”和“.”是否出现过。

	* 对于“+/-”： 正常来看它们第一次出现的话应该出现在字符串的第一个位置，如果它第一次出现在不是字符串首位，而且它的前面也不是“e/E”，那就不符合规则；如果是第二次出现，那么它就应该出现在“e/E”的后面，如果“+/-”的前面不是“e/E”，那也不符合规则。
对于“e/E”： 如果它的后面不接任何数字，就不符合规则；如果出现多个“e/E”也不符合规则。
对于“.”： 出现多个“.”是不符合规则的。还有“e/E”的字符串出现“.”也是不符合规则的。
同时，要保证其他字符均为 0-9 之间的数字。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_49 {
    public boolean isNumberic(char[] str) {
        int len = str.length;
        boolean sign = false;
        boolean decimal = false;
        boolean hasE = false;
        for (int i = 0; i < len; i++) {
            if (str[i] == '+' || str[i] == '-') {
                if (!sign && i > 0 && str[i - 1] != 'e' && str[i - 1] != 'E') {
                    return false;
                }
            } else if (str[i] == 'e' || str[i] == 'E') {
                if (i == len - 1) {
                    return false;
                }
                if (hasE) {
                    return true;
                }
                hasE = true;
            } else if (str[i] == '.') {
                if (hasE || decimal) {
                    return false;
                }
                decimal = true;
            } else if (str[i] < '0' || str[i] > '9']) {
                return false;
            }
        } 
        return false;
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 50. <span id="字符流中第一个不重复的字符">字符流中第一个不重复的字符-字符串</span>

1. **题目描述**：
请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。

2. **解题思路**：
	* 用一个哈希表来存储每个字符及其出现的次数，另外用一个字符串 s 来保存字符流中字符的顺序。

	* 每次插入的时候，在字符串 s 中插入该字符，然后在哈希表中查看是否存在该字符，如果存在则它的 value 加1，如果不存在，它在哈希表中插入该字符，它的 value 为 1。
查找第一个只出现一次的字符时，按照 s 的顺序，依次查找 map 中字符出现的次数，当 value 为 1 时，该字符就是第一个只出现一次的字符。

<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.HashMap;
public class Solution_50 {
    HashMap<Character, Integer> map = new HashMap<>();
    StringBuilder s = new StringBuilder();
    //Insert one char from stringstream
    public void Insert(char ch) {
        s.append(ch);
        if (map.containsKey(ch)) {
            map.put(ch, map.get(ch) + 1);
        } else {
            map.put(ch, 1);
        }
    }
    //return the first appearence once char in current stringstream
    public char firstAppearingOnce() {
        for (int i = 0; i < s.length(); i++) {
            if (map.get(s.charAt(i)) == 1) {
                return s.charAt(i);
            }
        }
        return '#';
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 51. <span id="链表中环的入口结点">链表中环的入口结点-链表</span>

1. **题目描述**： 
给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。

2. **解题思路**：
	* 一种方法是用 hashmap来存储和查找节点;
	* 另一种方法是双指针法。

	* 假设环长度为n，进入环之前结点个数为x,slow在环内走了k个结点,fast绕环走了m圈,则有2(x+k)=x+mn+k 可以得出x = mn - k。此时slow距入口结点还剩 n-k个结点,x=(m−1)n+n−k，即一个指针从链表头节点走到环入口的长度等于另一个指针从相遇的位置走 m-1圈后再走n-k的长度，也就是说两个指针相遇后，让一个指针回到头节点，另一个指针不动，然后他们同时往前每次走一步，当他们相遇时，相遇的节点即为环入口节点。

	* 所以，我们设置两个指针，一个是快指针fast，一个是慢指针slow，fast一次走两步，slow一次走一步，如果单链表有环那么当两个指针相遇时一定在环内。此时将一个指针指到链表头部，另一个不变，二者同时每次向前移一格,当两个指针再次相遇时即为环的入口节点。如果fast走到null则无环。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_51 {
    public ListNode EntryNodeOfLoop(ListNode pHead) {
        if(pHead.next == null || pHead.next.next == null)
            return null;
        ListNode slow = pHead.next;
        ListNode fast = pHead.next.next;
        while(fast != null){
            if(fast == slow){
                fast = pHead;
                while(fast != slow){
                    fast = fast.next;
                    slow = slow.next;
                }
                return fast;
            }
            slow = slow.next;
            fast = fast.next.next;
        }
        return null;
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 52. <span id="删除链表中重复的结点">删除链表中重复的结点-链表</span>

1. **题目描述**：
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

2. **解题思路**：
	* 首先添加一个头节点，以方便碰到第一个，第二个节点就相同的情况
	* 设置 first ，second 指针， first 指针指向当前确定不重复的那个节点，而second指针相当于工作指针，一直往后面搜索。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_52 {
    public ListNode deleteDuplication(ListNode pHead) {
        if (pHead == null || pHead.next == null) {
            return pHead;
        }
        ListNode head = new ListNode(-1);
        head.next = pHead;
        ListNode first = head;
        ListNode second = first.next;
        while (second != null) {
            if (second.next != null && second.val == second.next.val) {
                while (second.next != null && second.val == second.next.val) {
                    second = second.next;
                } 
                // 这步是将重读字段最后的字段整没
                first.next = second.next;
            } else {
                first = first.next;
            }
            second = second.next;
        }
        return head.next;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 53. <span id="二叉树的下一个结点">二叉树的下一个结点-树</span>

1. **题目描述**: 
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

2. **解题思路**: 
中序遍历：左 -> 根 -> 右
分三种情况：
	* 如果当前节点为空，直接返回空；
	* 如果当前节点有右子树，则返回右子树的最左子树；
	* 如果当前节点没有右子树，再分两种情况：
		1. 看看当前节点是不是它的父节点的左子树，如果是，则返回它的父节点；
		2. 如果当前节点不是它的父节点的左子树，则把父节点赋给当前节点，再判断当前节点是不是它的父节点的左子树，直到当前节点是不是它的父节点的左子树，返回它的父节点。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_53 {
    public TreeLinkNode GetNext(TreeLinkNode pNode)
    {
        if(pNode == null){
            return null;
        }
        if(pNode.right != null){
            TreeLinkNode node = pNode.right;
            while(node.left != null){
                node = node.left;
            }
            return node;
        }
        while(pNode.next != null){
            TreeLinkNode root = pNode.next;
            if(pNode == root.left)
                return root;
            pNode = root;
        }
        return null;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 54. <span id="对称的二叉树">对称的二叉树-树</span>

1. **题目描述**: 
请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

2. **解题思路**: 
	* 法一：递归。根节点的左右子树相同，左子树的左子树和右子树的右子树相同，左子树的右子树和右子树的左子树相同即可。
	* 法二：非递归。非递归也是一样，采用栈或队列存取各级子树根节点。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_54 {
    public boolean isSymmetrical(TreeNode pRoot) {
        if (pRoot == null) {
            return true;
        }
        return isSymmetrical(pRoot.left, pRoot.right);
    } 
    // 根节点的左右子树相同，左子树的左子树和右子树的右子树相同，
    // 左子树的右子树和右子树的左子树相同即可。
    public boolean isSymmetrical(TreeNode left, TreeNode right) {
        if (left == null && right == null) {
            return true;
        }
        if (left == null || right == null) {
            return false;
        }
        if (left.val == right.val) {
            return isSymmetrical(left.left, right.right) && 
                isSymmetrical(left.right, right.left);
        }
        return false;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 55. <span id="按之字形顺序打印二叉树">按之字形顺序打印二叉树-树</span>

1. **题目描述**: 
请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。

2. **解题思路**: 
设两个栈，s2存放奇数层，s1存放偶数层
	* 遍历s2节点的同时按照左子树、右子树的顺序加入s1，
	* 遍历s1节点的同时按照右子树、左子树的顺序加入s2

<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.ArrayList;
import java.util.Stack;
public class Solution_55 {
    public ArrayList<ArrayList<Integer>> print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();
        Stack<TreeNode> s1 = new Stack<>();
        Stack<TreeNode> s2 = new Stack<>();
        int flag = 1;
        if (pRoot == null) {
            return res;
        }
        s2.push(pRoot);
        ArrayList<Integer> temp = new ArrayList<>();
        while(!s1.isEmpty() || !s2.isEmpty()) {
            if (flag % 2 != 0) {
                while (!s2.isEmpty()) {
                    TreeNode node = s2.pop();
                    temp.add(node.val);
                    if (node.left != null) {
                        s1.push(node.left);
                    }
                    if (node.right != null) {
                        s1.push(node.right);
                    }
                }
            }
            if (flag % 2 == 0) {
                TreeNode node = s1.pop();
                temp.add(node.val);
                if (node.right != null) {
                    s2.push(node.right);
                }
                if (node.left != null) {
                    s2.push(node.left);
                }
            }
            res.add(new ArrayList<Integer>(temp));
            temp.clear();
            flag ++;
        }
        return res;
    } 
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 56. <span id="把二叉树打印成多行">把二叉树打印成多行-树</span>

1. **题目描述**: 
从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。

2. **解题思路**: 
就是二叉树的层序遍历，用队列来实现。我们需要两个变量，一个start记录当前层已经打印的节点个数，一个end记录前当层所有的节点个数，当 start == end 时，表时当前层遍历完了，就可以开始下一层遍历。

<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
public class Solution_56 {
    public ArrayList<ArrayList<Integer>> print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();
        if (pRoot == null) {
            return res;
        }
        ArrayList<Integer> temp = new ArrayList<>();
        Queue<TreeNode> layer = new LinkedList<>();
        layer.offer(pRoot);
        int start = 0;
        int end = 1;
        while (!layer.isEmpty()) {
            TreeNode node = layer.poll();
            temp.add(node.val);
            start++;
            if (node.left != null) {
                layer.add(node.left);
            }
            if (node.right != null) {
                layer.add(node.right);
            }
            if (start == end) {
                start = 0;
                res.add(temp);
                temp = new ArrayList<Integer>();
                end = layer.size();
            }
        }
        return res;
    } 
}
```
</code></pre>
</details>



- [backup](#1)

<HR>

#### 57. <span id="序列化二叉树">序列化二叉树-树</span>

1. **题目描述**: 
请实现两个函数，分别用来序列化和反序列化二叉树

2. **解题思路**: 
对于序列化：使用前序遍历，递归的将二叉树的值转化为字符，并且在每次二叉树的结点不为空时，在转化val所得的字符之后添加一个’,’作为分割; 对于空节点则以 ‘#,’ 代替。
对于反序列化：将字符串按照“，”进行分割，插入到队列中，然后依次从队列中取出字符建立节点，递归创建一个二叉树。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_57 {
    public String Serialize(TreeNode root) {
        if (root == null) {
            return "#";
        }
        StringBuffer res = new StringBuffer(root.val + ",");
        res.append(Serialize(root.left));
        res.append(Serialize(root.right));
        return res.toString();
    }
    public TreeNode Deserialize(String str) {
        String[] res = str.split(",");
        Queue<String> queue = new LinkedList<String>();
        for (int i = 0; i < res.length; i++) {
            queue.offer(res[i]);
        }
        return pre(queue);
    }
    private TreeNode pre(Queue<String> queue) {
        String val = queue.poll();
        if (val.equals("#")) {
            return null;
        }
        TreeNode node = new TreeNode(Integer.parseInt(val));
        node.left = pre(queue);
        node.right = pre(queue);
        return node;
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 58. <span id="二叉搜索树的第k个结点">二叉搜索树的第k个结点-树</span>

1. **题目描述**: 
给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。

2. **解题思路**: 
因为二叉搜索树按照中序遍历的顺序打印出来就是排好序的，所以，我们按照中序遍历找到第k个结点就是题目所求的结点。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_58 {
    int index = 0;
    TreeNode KthNode(TreeNode pRoot, int k) {
        if (pRoot != null) {
            TreeNode node = KthNode(pRoot.left, k);
            if (node != null) {
                return node;
            }
            index++;
            if (index == k) {
                return pRoot;
            }
            node = KthNode(pRoot.right, k);
            if (node != null) { 
                return node;
            }
        }
        return null;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 59. <span id="数据流中的中位数">数据流中的中位数-数值</span>

1. **题目描述**: 
如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。

2. **解题思路**: 
我们可以将数据排序后分为两部分，左边部分的数据总是比右边的数据小。那么，我们就可以用最大堆和最小堆来装载这些数据：
	* 最大堆装左边的数据，取出堆顶（最大的数）的时间复杂度是O(1)
	* 最小堆装右边的数据，同样，取出堆顶（最小的数）的时间复杂度是O(1)
	* 从数据流中拿到一个数后，先按顺序插入堆中：如果左边的最大堆是否为空或者该数小于等于最大堆顶的数，则把它插入最大堆，否则插入最小堆。然后，我们要保证左边的最大堆的size等于右边的最小堆的size或者最大堆的size比最小堆的size大1。
	* 要获取中位数的话，直接判断最大堆和最小堆的size，如果相等，则分别取出两个堆的堆顶除以2得到中位数，不然，就是最大堆的size要比最小堆的size大，这时直接取出最大堆的堆顶就是我们要的中位数。


<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.Comparator;
import java.util.PriorityQueue;
public class Solution_59 {
    // 最小堆(右)
    private PriorityQueue<Integer> rHeap = new PriorityQueue<>();
    // 最大堆(左)
    private PriorityQueue<Integer> lHeap = new PriorityQueue<>(15, new Comparator<Integer>() {
        public int compare(Integer o1, Integer o2) {
            return o2 - o1;
        }
    });
    // 保证 lHeap.size() >= rHeap.size()
    public void Insert(Integer num) {
        // 先按大小插入，再调整
        if (lHeap.isEmpty() || num <= lHeap.peek()) {
            lHeap.offer(num);
        } else {
            rHeap.offer(num);
        }
        if (lHeap.size() < rHeap.size()) {
            lHeap.offer(rHeap.peek());
            rHeap.poll();
        } else if (lHeap.size() - rHeap.size() == 2) {
            rHeap.offer(lHeap.peek());
            lHeap.poll();
        }
    }
    // 这里才是获取medina，获取中位数的值
    public Double GetMedian() {
        if (lHeap.size() > rHeap.size()) {
            return new Double(lHeap.peek());
        } else {
            return new Double(lHeap.peek() + rHeap.peek()) / 2;
        }
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 60. <span id="滑动窗口的最大值">滑动窗口的最大值-数组</span>

1. **题目描述**: 
给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。

2. **解题思路**: 
	* 法一：简单的暴力法
	* 法二：双向队列
用一个双向队列，队列第一个位置保存当前窗口的最大值，当窗口滑动一次，判断当前最大值是否过期（当前最大值的位置是不是在窗口之外），新增加的值从队尾开始比较，把所有比他小的值丢掉。这样时间复杂度为O(n)。

<details>
<summary>展开查看</summary>
<pre><code>
```
import java.util.ArrayList;
public class Solution_60 {
    public ArrayList<Integer> maxInWindows(int[] num, int size) {
        ArrayList<Integer> res = new ArrayList<>();
        if (num.length < size || size == 0) {
            return res;
        }
        for (int i = 0; i < num.length - size + 1; i++) {
            res.add(max(num, i, size));
        }
        return res;
    }
    public int max(int[] num, int index, int size) {
        int res = num[index];
        for (int i = index + 1; i < index + size; i++) {
            if (num[i] > res) {
                res = num[i];
            }
        }
        return res;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

#### 61. <span id="矩阵中的路径">矩阵中的路径-数组</span>

1. **题目描述**: 
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。

2. **解题思路**: 
回溯法：
	1. 将matrix字符串映射为一个字符矩阵（index = i * cols + j）
	2. 遍历matrix的每个坐标，与str的首个字符对比，如果相同，用flag做标记，matrix的坐标分别上、下、左、右、移动（判断是否出界或者之前已经走过[flag的坐标为1]），再和str的下一个坐标相比，直到str全部对比完，即找到路径，否则找不到。


<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_61 {
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {
        if (matrix.length == 0 || str.length == 0) {
            return false;
        }
        int[][] flag = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < rows; j++) {
                if (search(matrix, rows, cols, i, j, str, 0, flag)) {
                    return true;
                }
            }
        }
        return false;
    }
    public boolean search(char[] matrix, int rows, int cols, int i, int j, char[] str, int index, int[][] flag) {
        // 这里是将i变为第二行，因为传进来的是一个一维数组，不是二维数组
        // 将matrix字符串映射为一个字符矩阵
        int m_i = i * cols + j;
        if (i < 0 || j < 0 || j >= rows || j >= cols || 
                flag[i][j] == 1 || matrix[m_i] != str[index]) {
            return false;
        }
        if (index >= str.length - 1) {
            return true;
        }
        // 这里是如果递归中有符合matrix[m_i] != str[index]条件的，
        // 会在下面的if中直接返回true
        flag[i][j] = 1;
        if (search(matrix, rows, cols, i + 1, j, str, index + 1, flag) || 
              search(matrix, rows, cols, i - 1, j, str, index + 1, flag) || 
              search(matrix, rows, cols, i, j + 1, str, index + 1, flag) || 
              search(matrix, rows, cols, i, j - 1, str, index + 1, flag)) {
            return true;
        }
        flag[i][j] = 0;
        return false;
    }
}
```
</code></pre>
</details>

- [backup](#1)

<HR>

#### 62. <span id="机器人的运动范围">机器人的运动范围-数组</span>

1. **题目描述**: 
地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？

2. **解题思路**: 
回溯法：从(0,0)开始走，每成功走一步用一个flag数组标记当前位置为1，然后从当前位置往四个方向探索，返回1 + 4 个方向的探索值之和。

<details>
<summary>展开查看</summary>
<pre><code>
```
public class Solution_62 {
    // threshold：表示限制的阀值
    public int movingCount(int threshold, int rows, int cols) {
        if (threshold == 0) {
            return 0;
        }
        int flag[][] = new int[rows][cols];
        return count(threshold, rows, cols, 0, 0, flag);
    }
    // 这里是个递归函数，实际上记录的是可以走的格子的数量
    // 每个格子都有自己探索上下左右的递归，超出界限了就返回0
    public int count(int threshold, int rows, int cols, int i, int j, int[][] flag) {
        if (i < 0 || j < 0 || j >= rows || j >= cols || 
            sum(i) + sum(j) > threshold || flag[i][j] == 1) {
            return 0;
        }
        flag[i][j] = 1;
        return 1 + count(threshold, rows, cols, i - 1, j, flag) + 
            count(threshold, rows, cols, i + 1, j, flag) + 
            count(threshold, rows, cols, i, j - 1, flag) + 
            count(threshold, rows, cols, i, j + 1, flag);
    }
    public int sum(int i) {
        int s = 0;
        // 这里是逐位相加，从个位开始向高位，位数没有限制
        while (i > 0) {
            s += i%10;
            i /= 10;
        }
        return s;
    }
}
```
</code></pre>
</details>


- [backup](#1)

<HR>

​	
​	
​	
​	
​	
​	
​	
