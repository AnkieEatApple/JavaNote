## 数据库.md
##### 1. 目录

- [一、数据库架构](#framework)
- [二、优化你的索引](#search)
- [三、密集索引和稀疏索引的区别](#distinction)
- [四、索引额外的问题](#quesiton)
- [五、锁模块-MyISAM与InnoDB关于锁方面的区别](#myIsam)
- [六、锁模块-数据库事务的四大特征](#event)
- [七、锁模块-事物并发访问产生的问题以及事物隔离机制](#intercurrent)
- [八、锁模块-当前读和快照读](#read)
- [九、锁模块-RR如何避免幻读](#wrongread)
- [十、关键语法讲解](#grammer)

	

### 一、<span id="framework">数据库架构</span>
1. 关系型数据库的主要考点<br/>![WeChat3ae3e70b5b7ddae0d607038f38f19a40.png](https://i.loli.net/2019/09/12/lUSaqYizudFpmKX.png)

#### 1.1 问题1: 如何设计一个关系型数据库
1. **储存**部分：储存我们的数据，RDBMS，需要有储存(文件系统，存储在机械硬盘或者SSD固态硬盘中)和程序实例
2. **程序实例**部分：
	2. 存储管理：**磁盘IO速率往往是影响程序执行速度的主要瓶颈**，读取机械硬盘和SSD速度都**比内存小**，一次IO读取单行和多行速度差不多
	3. 缓存机制：优化执行效率，引入缓存机制，吧取出来的数据块放在缓存里，需要直接从内存返回
	4. SQL解析：将sql缓存到我们的缓存里，可以优化。缓存不宜过大，有淘汰机制
	5. 日志管理，binlog机制，记录操作的历史
	6. 权限划分，多用户管理的权限划分
	7. 容灾机制，灾难恢复模块
	8. 索引管理：优化查找效率的索引模块
	9. 锁管理：支持并发操作的锁模块
3. 图示关系为：<br/>

#### 1.2 索引模块
1. 常见问题
	1. 为什么要使用索引
	2. 什么样的信息能成为索引
	3. 索引的数据结构
	4. 密集索引和稀疏索引的区别

##### 1.2.1 为什么要使用索引
1. 最简单的数据查询方式是**全表扫描**，即将整张表或分批次加载到内存当中
2. 储存的最小单位是**块**或者**页**，它们是由多行数据组成的，将这些块都加载进来，然后逐个块去轮训，找到我们要的目标并返回。这种适合比较少量的数据，不适用大量的数据
3. 索引的目的是为了在大量的数据中，快速查询数据

##### 1.2.2 什么样的信息能成为索引
1. 主键、唯一键以及普通键等可以成为索引

##### 1.2.3 索引的数据结构
1. 生成索引，建立二叉查找树进行二分查找
2. 生成索引，建立B-Tree结构进行查找
3. 生成索引，建立B+-Tree结构进行查找
4. 生成索引，建立Hash结构进行查找

  




### 二、<span id="search">优化你的索引</span>

##### 1. 目录
- [2.1 运用二叉查找树](#serachTree)
- [2.2 运用B树](#BTree)
- [2.3 运用B+树](#BPlusTree)
- [2.4 运用Hash以及BitMap](#Hash)


#### 2.1 <span id="serachTree">运用二叉查找树</span>
1. 二叉查找树(Binary Search Tree)，又称二叉搜索树，二叉排序树，通常只有leftTree和rightTree两个节点
3. 这个二叉树，不仅仅是搜索二叉树，还是**平衡二叉树**，平衡二叉树的任意一个左子树，它的高度均不操过1，根部的左子树和根部的右子树最大差1
4. 查找的数据的方式是二分查找，算法的复杂度是O(logn)
5. 若是早CRUD操作中，删除了某些及节点，又添加了某些节点，可能会造成查找树变成线性树，时间复杂度变为了O(n)<br/>![WeChatc3f4adf4846958a476a0532b9b68da39.png](https://i.loli.net/2019/09/12/cYmQGeyHP83S17n.png)
6. **解决办法**1: 可以通过树的旋转，来将查找树改变为平衡树，这样时间复杂度会降下来，为O(logn)
7. **索引的运行瓶颈在IO**，索引快在磁盘中，先发生的事将5读入到内存中，再将7读入到内存，然后再读6到内存中，这样随着数据的增多，树的深度也会增大，检索的效率不比全表检索快
8. **解决办法**2: **如何既减少事件复杂度，同时减少IO读取次数**，就是将树矮一些，同时树存储的数据多一些


#### 2.2 <span id="BTree">运用B树</span>
1. B-Tree的结构，图示是一个三阶B树的样子，正常情况下，每个字节点的数量是很大于3的<br/>![WeChat1ae60da01a39fd2e807bd7c128ac9b05.png](https://i.loli.net/2019/09/12/kldJ31q9oeFtKy7.png)

2. 定义
	* 根节点至少包括两个孩子，存在非跟非叶子节点
	* 树中每个节点最多有m个孩子(m >= 2)
	* 除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子，这里ceil向上取整
	* 所有叶子节点都位于同一层

3. 假设每个非终端节点中包含有n个关键字信息，其中
	1. Ki(i=1...n)为关键字，且关键字按顺序生序排序K(i-1) < Ki，升序排列的
	2. 关键字的个数n必须满足：[ceil(m/2) - 1] <= n <= m-1，关键字个数比孩子节点个数少一个
	3. 非叶子节点的指针：P[1], P[2], ..., P[M]; 其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于(K[i-1], K[i])的子树
4. B数可以通过合并、上移、下移、分裂等方法避免线性树的产生  

#### 2.3 <span id="BPlusTree">运用B+树</span>
1. B+数是B数的变体，其定义基本与B数相同，除了：
	* 非叶子节点的子树指针与关键字个数相同
	* 非叶子节点的子树指针P[i]，指向关键字值[K[i], K[i + 1]]的子树
	* 非叶子节点仅用来索引，数据都保存在叶子节点中
	* 所有叶子节点均有一个连指针指向下一个叶子节点，并按大小顺序链接，这样可以支持范围统计，可以横向的跨子树进行统计
2. B+树的图示<br/>![WeChatcd179df89460a538b498753fed27e21a.png](https://i.loli.net/2019/09/12/YwJsW5e3vVGECLc.png)

3. B+Tree更适合用来做存储索引
	* B+树的磁盘读写代价更低
	* B+数的查询效率更加稳定
	* B+树更有利于对数据库的扫描，更适用于范围查询 


#### 2.4 <span id="Hash">运用Hash以及BitMap</span>
1. Hash索引的图示<br/>![WeChatffb8097c9be5b52d7c98d31d7262cd7b.png](https://i.loli.net/2019/09/12/F69bln4KGYWHzJU.png)
2. 缺点
	* 仅仅能满足“=”，“IN”，不能使用范围查询
	* 无法被用来避免数据的排序操作
	* 不能利用部分索引键查询
	* 不能避免表扫描，
	* 遇到大量Hash值相等的情况后，性能并不一定就会比BTree索引高，bucket桶可能存在重复，之后会形成线性链表或树结构等

3. BitMap索引，只有Oracle支持，图示<br/>![WeChat15e6bd0b79a89d1ee6396d5740c6bf10.png](https://i.loli.net/2019/09/12/WHalozKyCsP64BO.png)

4. BitMap索引类似于B+索引，通过Byte位来查找，所以操作比较快
5. 锁的粒度非常的大，若改变一个位，整个位图就需要全部锁定，这样就不是很适合高并发操作

### 三、<span id="disctinction">密集索引和稀疏索引的区别</span>
1. 密集索引和稀疏索引的区别
	* 密集索引文件中的每个搜索码都对应一个索引值
	* 稀疏索引文件只为索引吗的某些值建立索引项

2. 图示<br/>![WeChataef5c4f9e3ad3d22e2a0933f8238d211.png](https://i.loli.net/2019/09/12/xfy83rIV6jngKuY.png)
3. **密集索引**：叶子节点保存的不仅仅是键值，还保存了位于同一行记录里的其他列的信息，由于密集索引决定了表的物理排列顺序，一个表只能有一个物理排列顺序，所以一个表只能创建一个密集索引
4. **稀疏索引**：叶子节点仅保存了键位信息，以及该行数据的地址，某些稀疏索引仅保持了键位信息和及其主键

#### 3.1 对MySql的搜索引擎具体分析
1. MySql主要由两种引擎，一种是MyISAM，另一种是InnoDB，这两种是主流
2. MyISAM不管是主键索引、唯一键索引或者普通索引，其索引均属于稀疏索引
3. InnoDB有且仅有一个密集索引
	* 若一个主键被定义，该主键则为密集索引
	* 若没有主键被定义，该表的第一个唯一非空索引则为密集索引
	* 若不满足以上条件，InnoDB内部会生成一个隐藏主键(密集索引)，是一个6字节的列，会随着数据的插入而自增
	* 非主键索引存储相关键位和其对应的主键值，包含两次查找， 一次是查找次级索引自身，一次是查找主键
4. 额外的知识<br/>![WeChat9911c36dc70161383af5a128cdff0f57.png](https://i.loli.net/2019/09/12/5MhxkrSuP1eDn9f.png)
5. InnoBD，使用的是密集索引，将主键组织到一棵B+树中，而行数据就存储在叶子节点上，因为InnoDB的主键索引和对应的数据是保存在同一个文件当中的，所以检索的时候，在加载叶子节点的主键加入内存的同时，也加载了对应的数据。<br/>eg：按照上面的图片，就是where id=14这样的条件查询主键，按照B+树的查找算法，可以查找对应的叶子节点，并获得对应的行数据，
6. InnoDB，若对稀疏索引进行条件筛选，则需要进行两个步骤， 
	* 第一步在稀疏索引的B+树中检索该键，比如Elison这个主键信息14
	* 第二步再执行B+树中的检索操作，然后到达叶子节点获取整行的数据

### 四、<span id="question">索引额外的问题</span>


### 五、<span id="myIsam">锁模块-MyISAM与InnoDB关于锁方面的区别</span>


### 六、<span id="event">锁模块-数据库事务的四大特征</span>


### 七、<span id="intercurrnet">锁模块-事物并发访问产生的问题以及事物隔离机制</span>




### 八、<span id="read">锁模块-当前读和快照读</span>




### 九、<span id="wrongread">锁模块-RR如何避免幻读</span>




### 十、<span id="grammer">关键语法讲解</span>








